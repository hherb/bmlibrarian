"""
Report Formatting Module

Handles markdown report generation, file export utilities, and citation formatting.
"""

import os
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional
from bmlibrarian.agents import Report, Citation, CounterfactualAnalysis


class ReportFormatter:
    """Handles report formatting and export operations."""
    
    def __init__(self, config, ui):
        self.config = config
        self.ui = ui
    
    def format_report_as_markdown(self, report: Report, counterfactual_analysis: Optional[CounterfactualAnalysis] = None) -> str:
        """Format report as markdown with proper structure."""
        lines = []
        
        # Title and metadata
        lines.append(f"# Medical Literature Research Report")
        lines.append("")
        lines.append(f"**Generated by BMLibrarian CLI**  ")
        lines.append(f"**Date:** {report.created_at.strftime('%Y-%m-%d %H:%M:%S UTC')}  ")
        lines.append(f"**Evidence Strength:** {report.evidence_strength}  ")
        lines.append("")
        
        # Research question
        lines.append("## Research Question")
        lines.append("")
        lines.append(f"> {report.user_question}")
        lines.append("")
        
        # Evidence assessment
        lines.append("## Evidence Assessment")
        lines.append("")
        lines.append(f"- **Evidence Strength:** {report.evidence_strength}")
        lines.append(f"- **Citations Analyzed:** {report.citation_count}")
        lines.append(f"- **Unique References:** {report.unique_documents}")
        lines.append("")
        
        # Synthesized answer
        lines.append("## Findings")
        lines.append("")
        lines.append(report.synthesized_answer)
        lines.append("")
        
        # References
        lines.append("## References")
        lines.append("")
        for ref in report.references:
            formatted_ref = ref.format_vancouver_style()
            lines.append(f"{ref.number}. {formatted_ref}")
        lines.append("")
        
        # Methodology
        if report.methodology_note:
            lines.append("## Methodology")
            lines.append("")
            lines.append(report.methodology_note)
            lines.append("")
        
        # Add counterfactual analysis section if available
        if counterfactual_analysis:
            lines.extend(self._get_counterfactual_analysis_section(counterfactual_analysis))
        
        # Technical details
        lines.extend(self._get_technical_details_section())
        
        return "\n".join(lines)
    
    def _get_technical_details_section(self) -> List[str]:
        """Get technical details section for the report."""
        lines = []
        
        lines.append("## Technical Details")
        lines.append("")
        lines.append("This report was generated using the BMLibrarian multi-agent system:")
        lines.append("")
        lines.append("1. **Query Generation:** Natural language question converted to database query")
        lines.append("2. **Document Retrieval:** PostgreSQL full-text search with pgvector extension")
        lines.append("3. **Relevance Scoring:** AI-powered document scoring (1-5 scale)")
        lines.append("4. **Citation Extraction:** Relevant passage extraction from high-scoring documents")
        lines.append("5. **Report Synthesis:** Medical publication-style report generation")
        lines.append("")
        lines.append("**AI Models Used:**")
        lines.append("- Document scoring and citation extraction: LLM via Ollama")
        lines.append("- Report synthesis: Medical writing-focused language model")
        lines.append("")
        lines.append("**Quality Controls:**")
        lines.append("- Document ID verification prevents citation hallucination")
        lines.append("- Evidence strength assessment based on citation quality and quantity")
        lines.append("- Human-in-the-loop validation at each processing step")
        
        return lines
    
    def _get_counterfactual_analysis_section(self, analysis: CounterfactualAnalysis) -> List[str]:
        """Get counterfactual analysis section for the report."""
        lines = []
        
        lines.append("## Counterfactual Analysis")
        lines.append("")
        lines.append(f"**Original Confidence Level:** {analysis.confidence_level}")
        lines.append("")
        lines.append("### Main Claims Analyzed")
        lines.append("")
        for i, claim in enumerate(analysis.main_claims, 1):
            lines.append(f"{i}. {claim}")
        lines.append("")
        
        lines.append("### Research Questions for Contradictory Evidence")
        lines.append("")
        
        # Group questions by priority
        high_priority = [q for q in analysis.counterfactual_questions if q.priority == "HIGH"]
        medium_priority = [q for q in analysis.counterfactual_questions if q.priority == "MEDIUM"]
        low_priority = [q for q in analysis.counterfactual_questions if q.priority == "LOW"]
        
        if high_priority:
            lines.append("#### High Priority Questions")
            lines.append("")
            for i, question in enumerate(high_priority, 1):
                lines.append(f"**Question {i}:** {question.question}")
                lines.append("")
                lines.append(f"*Target Claim:* {question.target_claim}")
                lines.append("")
                lines.append(f"*Reasoning:* {question.reasoning}")
                lines.append("")
                lines.append(f"*Search Keywords:* {', '.join(question.search_keywords)}")
                lines.append("")
                lines.append("---")
                lines.append("")
        
        if medium_priority:
            lines.append("#### Medium Priority Questions")
            lines.append("")
            for i, question in enumerate(medium_priority, 1):
                lines.append(f"**Question {i}:** {question.question}")
                lines.append("")
                lines.append(f"*Target Claim:* {question.target_claim}")
                lines.append("")
                lines.append(f"*Search Keywords:* {', '.join(question.search_keywords)}")
                lines.append("")
        
        if low_priority:
            lines.append("#### Low Priority Questions")
            lines.append("")
            for i, question in enumerate(low_priority, 1):
                lines.append(f"**Question {i}:** {question.question}")
                lines.append("")
        
        lines.append("### Overall Assessment")
        lines.append("")
        lines.append(analysis.overall_assessment)
        lines.append("")
        
        return lines
    
    def save_report_to_file(self, report: Report, question: str, counterfactual_analysis: Optional[CounterfactualAnalysis] = None) -> bool:
        """Save the generated report as a markdown file with user interaction."""
        try:
            # Get filename from user
            filename = self.ui.get_report_filename(question)
            
            # Convert report to markdown format
            markdown_content = self.format_report_as_markdown(report, counterfactual_analysis)
            
            # Save file
            with open(filename, 'w', encoding='utf-8') as f:
                f.write(markdown_content)
            
            # Show confirmation
            file_size = os.path.getsize(filename)
            self.ui.show_file_saved(filename, file_size, markdown_content)
            
            return True
            
        except Exception as e:
            self.ui.show_error_message(f"Error saving report: {e}")
            return False
    
    def format_citation_summary(self, citations: List[Citation]) -> str:
        """Format a summary of citations for display."""
        if not citations:
            return "No citations available."
        
        lines = []
        lines.append(f"Citation Summary ({len(citations)} citations):")
        lines.append("=" * 50)
        
        # Group citations by document
        doc_citations = {}
        for citation in citations:
            doc_id = citation.document_id
            if doc_id not in doc_citations:
                doc_citations[doc_id] = []
            doc_citations[doc_id].append(citation)
        
        # Format by document
        for doc_id, doc_citations_list in doc_citations.items():
            first_citation = doc_citations_list[0]
            lines.append(f"\nðŸ“„ {first_citation.document_title}")
            lines.append(f"   Authors: {', '.join(first_citation.authors[:3])}{'...' if len(first_citation.authors) > 3 else ''}")
            lines.append(f"   Date: {first_citation.publication_date}")
            lines.append(f"   Citations from this document: {len(doc_citations_list)}")
            
            # Show highest relevance citation
            best_citation = max(doc_citations_list, key=lambda c: c.relevance_score)
            lines.append(f"   Best passage (relevance: {best_citation.relevance_score:.3f}):")
            lines.append(f"   \"{best_citation.passage[:100]}...\"")
        
        return "\n".join(lines)
    
    def export_citations_to_csv(self, citations: List[Citation], filename: str = None) -> bool:
        """Export citations to CSV format."""
        try:
            import csv
            
            if filename is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"bmlibrarian_citations_{timestamp}.csv"
            
            with open(filename, 'w', newline='', encoding='utf-8') as csvfile:
                fieldnames = [
                    'document_id', 'document_title', 'authors', 'publication_date',
                    'passage', 'summary', 'relevance_score'
                ]
                writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
                
                writer.writeheader()
                for citation in citations:
                    writer.writerow({
                        'document_id': citation.document_id,
                        'document_title': citation.document_title,
                        'authors': '; '.join(citation.authors),
                        'publication_date': citation.publication_date,
                        'passage': citation.passage,
                        'summary': citation.summary,
                        'relevance_score': citation.relevance_score
                    })
            
            self.ui.show_success_message(f"Citations exported to: {filename}")
            return True
            
        except Exception as e:
            self.ui.show_error_message(f"Error exporting citations: {e}")
            return False
    
    def export_citations_to_json(self, citations: List[Citation], filename: str = None) -> bool:
        """Export citations to JSON format."""
        try:
            import json
            
            if filename is None:
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                filename = f"bmlibrarian_citations_{timestamp}.json"
            
            citations_data = []
            for citation in citations:
                citations_data.append({
                    'document_id': citation.document_id,
                    'document_title': citation.document_title,
                    'authors': citation.authors,
                    'publication_date': citation.publication_date,
                    'passage': citation.passage,
                    'summary': citation.summary,
                    'relevance_score': citation.relevance_score
                })
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(citations_data, f, indent=2, ensure_ascii=False)
            
            self.ui.show_success_message(f"Citations exported to: {filename}")
            return True
            
        except Exception as e:
            self.ui.show_error_message(f"Error exporting citations: {e}")
            return False
    
    def create_citation_bibliography(self, citations: List[Citation], 
                                   style: str = 'vancouver') -> str:
        """Create a bibliography from citations in specified style."""
        if not citations:
            return ""
        
        # Group citations by document to avoid duplicates
        unique_docs = {}
        for citation in citations:
            doc_id = citation.document_id
            if doc_id not in unique_docs:
                unique_docs[doc_id] = citation
        
        lines = []
        if style.lower() == 'vancouver':
            lines.append("## References (Vancouver Style)")
            lines.append("")
            
            for i, (doc_id, citation) in enumerate(unique_docs.items(), 1):
                ref_line = f"{i}. {self._format_vancouver_citation(citation)}"
                lines.append(ref_line)
        
        elif style.lower() == 'apa':
            lines.append("## References (APA Style)")
            lines.append("")
            
            # Sort by first author's last name for APA
            sorted_citations = sorted(unique_docs.values(), 
                                    key=lambda c: c.authors[0].split()[-1] if c.authors else '')
            
            for citation in sorted_citations:
                ref_line = self._format_apa_citation(citation)
                lines.append(ref_line)
                lines.append("")  # APA style uses line breaks between references
        
        return "\n".join(lines)
    
    def _format_vancouver_citation(self, citation: Citation) -> str:
        """Format a single citation in Vancouver style."""
        authors = citation.authors[:6]  # Vancouver typically shows up to 6 authors
        
        if len(authors) > 6:
            author_str = ", ".join(authors[:6]) + ", et al."
        else:
            author_str = ", ".join(authors)
        
        # Basic Vancouver format: Authors. Title. Journal. Year;Volume(Issue):Pages.
        parts = [author_str]
        
        if citation.document_title:
            parts.append(citation.document_title)
        
        # Add publication date if available
        if citation.publication_date:
            year = self._extract_year_from_date(citation.publication_date)
            if year:
                parts.append(f"{year}")
        
        return ". ".join(filter(None, parts)) + "."
    
    def _format_apa_citation(self, citation: Citation) -> str:
        """Format a single citation in APA style."""
        authors = citation.authors
        
        # Format authors (Last, F. M.)
        if authors:
            if len(authors) == 1:
                author_str = self._format_apa_author(authors[0])
            elif len(authors) <= 20:
                formatted_authors = [self._format_apa_author(author) for author in authors[:-1]]
                author_str = ", ".join(formatted_authors) + f", & {self._format_apa_author(authors[-1])}"
            else:
                # For more than 20 authors, show first 19, then "...", then last
                formatted_authors = [self._format_apa_author(author) for author in authors[:19]]
                author_str = ", ".join(formatted_authors) + f", ... {self._format_apa_author(authors[-1])}"
        else:
            author_str = "Unknown"
        
        # Add year
        year = self._extract_year_from_date(citation.publication_date) or "n.d."
        
        # Add title
        title = citation.document_title if citation.document_title else "Untitled"
        
        return f"{author_str} ({year}). {title}."
    
    def _format_apa_author(self, author_name: str) -> str:
        """Format a single author name for APA style."""
        # Split name into parts
        parts = author_name.strip().split()
        if len(parts) == 1:
            return parts[0]
        elif len(parts) == 2:
            # First Last -> Last, F.
            return f"{parts[-1]}, {parts[0][0]}."
        else:
            # First Middle Last -> Last, F. M.
            initials = " ".join([name[0] + "." for name in parts[:-1]])
            return f"{parts[-1]}, {initials}"
    
    def _extract_year_from_date(self, date_str: str) -> Optional[str]:
        """Extract year from date string."""
        if not date_str:
            return None
        
        import re
        year_match = re.search(r'\b(19|20)\d{2}\b', str(date_str))
        if year_match:
            return year_match.group()
        return None
    
    def generate_report_template(self, question: str) -> str:
        """Generate a basic report template for manual completion."""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        template = f"""# Medical Literature Research Report

**Generated by BMLibrarian CLI**  
**Date:** {timestamp}  
**Evidence Strength:** [To be determined]  

## Research Question

> {question}

## Evidence Assessment

- **Evidence Strength:** [To be determined]
- **Citations Analyzed:** [To be determined]
- **Unique References:** [To be determined]

## Findings

[Research findings will be generated here based on extracted citations]

## References

[References will be added during report generation]

## Methodology

This report was generated using the BMLibrarian multi-agent system with the following steps:

1. **Query Generation:** Natural language question converted to database query
2. **Document Retrieval:** PostgreSQL full-text search with pgvector extension
3. **Relevance Scoring:** AI-powered document scoring (1-5 scale)
4. **Citation Extraction:** Relevant passage extraction from high-scoring documents
5. **Report Synthesis:** Medical publication-style report generation

**Quality Controls:**
- Document ID verification prevents citation hallucination
- Evidence strength assessment based on citation quality and quantity
- Human-in-the-loop validation at each processing step
"""
        return template
    
    def validate_filename(self, filename: str) -> bool:
        """Validate filename for safety and compatibility."""
        try:
            # Check for valid characters
            invalid_chars = '<>:"|?*'
            if any(char in filename for char in invalid_chars):
                return False
            
            # Check length
            if len(filename) > 255:
                return False
            
            # Check for reserved names (Windows)
            reserved_names = ['CON', 'PRN', 'AUX', 'NUL', 'COM1', 'COM2', 'COM3', 'COM4', 
                            'COM5', 'COM6', 'COM7', 'COM8', 'COM9', 'LPT1', 'LPT2', 'LPT3', 
                            'LPT4', 'LPT5', 'LPT6', 'LPT7', 'LPT8', 'LPT9']
            
            name_without_ext = Path(filename).stem.upper()
            if name_without_ext in reserved_names:
                return False
            
            return True
            
        except:
            return False
    
    def create_backup_filename(self, original_filename: str) -> str:
        """Create a backup filename if the original exists."""
        path = Path(original_filename)
        counter = 1
        
        while path.exists():
            stem = path.stem
            suffix = path.suffix
            
            # Remove any existing counter
            if stem.endswith(f"_{counter-1}") and counter > 1:
                stem = stem[:-len(f"_{counter-1}")]
            
            new_filename = f"{stem}_{counter}{suffix}"
            path = Path(new_filename)
            counter += 1
        
        return str(path)